/**
 * Provides cross-browser abstractions for common browser operations
 *
 * (Despite the <inner> tags - all these methods are publicly exposed
 * @module browser_abstractions
 */
import ScPromise from './libs/promises';
/**
 * Listen to an event (this is essentially a wrapper around addEventListener)
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener}
 * @param evnt {string} the event you want to listen for
 * @param func {function} callback for when the event occurs
 * @param [elem=window] {element} the element to listen on (defaults to window if not supplied)
 */
export var on = function(evnt, func, elem) {
    if (elem === void 0) {
        elem = window;
    }
    if (elem && elem.addEventListener) {
        elem.addEventListener(evnt, func);
    }
};
/**
 * Stop listening to an event (this is essentially a wrapper around removeEventListener)
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/removeEventListener}
 * @param evnt {string} the event you want to stop listening for
 * @param func {function} the callback function you want to remove (same as the one you listened on)
 * @param [elem=window] {element} the element to stop listening on (defaults to window if not supplied)
 */
export var off = function(evnt, func, elem) {
    if (elem === void 0) {
        elem = window;
    }
    if (elem && elem.removeEventListener) {
        elem.removeEventListener(evnt, func);
    }
};
/**
 * @typedef location
 * @type {object}
 * @property {string} href - the full url
 * @property {port} port - the current port (usually 80)
 * @property {host} host - the current host name (with port where applicable)
 * @property {pathname} pathname - the current file path
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Location}
 */
/**
 * Get a subset of the window.location object
 * @returns {{...location}} {@link location}
 */
export var location = function() {
    return window.location;
};
/**
 * Get the browser's window object
 * NOTE: this is exposed as just window NOT browserWindow
 * @returns {window} the window object
 */
var browserWindow = function() {
    return window;
};
/**
 * Get the current document model object
 * NOTE: this is exposed as just document NOT browserDocument
 * @returns {HTMLDocument}
 */
var browserDocument = function() {
    return document;
};
/**
 * Get the browser's user agent string
 * @returns {string} the browser's user agent
 */
export var userAgent = function() {
    return browserWindow().navigator.userAgent;
};
/**
 * Get the current document title
 * @returns {string} the document title
 */
export var pageTitle = function() {
    return browserDocument().title;
};
/**
 * Get the current document referrer
 * @returns {string} the document referrer
 */
export var referrer = function() {
    return browserDocument().referrer;
};
/**
 * @typedef screenInfo
 * @type {object}
 * @property {number} availWidth - the available width
 * @property {number} availHeight - the available height
 * @property {number} width - the current width
 * @property {number} height - the current height
 * @property {number} depth - the current colour depth
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Screen}
 */
/**
 * Get a subset of the window.screen object with details of width, height and depth data
 * @returns {{screenInfo}}
 */
export var screenInfo = function() {
    var screen = browserWindow().screen;
    return {
        availHeight: screen.availHeight,
        availWidth: screen.availWidth,
        depth: screen.colorDepth,
        height: screen.height,
        width: screen.width
    };
};
/**
 * Get the current document cookie string, containing all cookies
 * (note, you can't use this to set cookies)
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Document/cookie}
 * @returns {string}
 */
export var documentCookie = function() {
    // tslint:disable-next-line:no-cookies
    return document.cookie;
};
/**
 * Fire any state change events we have based on the current loading status
 */
var fireStateChangeEvents = function() {
    var newState = document.readyState;
    if (newState === 'interactive') {
        // if interactive - fire off our interactive cbs
        if (browserWindow().__sc_contentReadyCBs) {
            browserWindow().__sc_contentReadyCBs.forEach(function(resolve) {
                return resolve();
            });
            delete browserWindow().__sc_contentReadyCBs;
        }
    } else if (newState === 'complete') {
        // if loaded - fire off all our callbacks
        if (browserWindow().__sc_contentReadyCBs) {
            browserWindow().__sc_contentReadyCBs.forEach(function(resolve) {
                return resolve();
            });
            delete browserWindow().__sc_contentReadyCBs;
        }
        if (browserWindow().__sc_domLoadedCBs) {
            browserWindow().__sc_domLoadedCBs.forEach(function(resolve) {
                return resolve();
            });
            delete browserWindow().__sc_domLoadedCBs;
        }
    }
};
if (document) {
    // I don't know why we need to do this rather than DomContentLoaded but there are cases where that doesn't work. Think it's a bug in chrome
    document.onreadystatechange = fireStateChangeEvents;
    if (document.addEventListener) {
        document.addEventListener('DOMContentLoaded', fireStateChangeEvents);
        document.addEventListener('load', fireStateChangeEvents);
    }
}
// buckle in sunshine and let me regale you with how this came to be
// traditionally after DOMContentLoaded has fired then the readystate of the page is
// either interactive or complete
//
// but, here's the kicker, it turns out if a service worker is attached it may remain as loading
// which means you can then be waiting for an event that never occurs, cos its already happened.
// so to get round this we listen for the event at a high level and record the fact that it has occurred
// on('DOMContentLoaded', fireStateChangeEvents, document);
// on('load', fireStateChangeEvents, window);
// on('readystatechange', fireStateChangeEvents, window);
/**
 * Wrapper around the DomContentLoaded event to make it cross browser compatible
 * this function will call your callback when the dom is interactive.
 *
 * If called after the dom is initialised, your callback will be called immediately
 * @see {@link https://developer.mozilla.org/en/docs/Web/API/Document/readyState}
 * @param callback {function} your callback function to be called when ready
 * @returns {undefined}
 */
export var waitForDom = function() {
    var state = document.readyState;
    return new ScPromise(function(resolve) {
        if (state === 'interactive' || state === 'complete') {
            return resolve();
        }
        if (browserWindow().__sc_contentReadyCBs) {
            browserWindow().__sc_contentReadyCBs.push(resolve);
        } else {
            browserWindow().__sc_contentReadyCBs = [resolve];
        }
    });
};
/**
 * Wrapper around he onload event to make it cross browser compatible, this function will call your callback only once
 * the document is fully loaded (readyState = complete).
 *
 * If called after the dom is complete, your callback will be called immediately
 * @see {@link https://developer.mozilla.org/en/docs/Web/API/Document/readyState}
 * @param callback {function} your callback function to be called when ready
 * @returns {undefined}
 */
export var waitForOnLoad = function() {
    return new ScPromise(function(resolve) {
        if (document.readyState === 'complete') {
            return resolve();
        }
        if (browserWindow().__sc_domLoadedCBs) {
            browserWindow().__sc_domLoadedCBs.push(resolve);
        } else {
            browserWindow().__sc_domLoadedCBs = [resolve];
        }
    });
};
/**
 * Check to see if we are capable of supporting this browser, this check ensures that the browser supports JSON and
 * the querySelectorAll function along with array.forEach and btoa (for reference this is IE10+)
 * @returns {boolean} true if supported, else false
 */
export var browserIsSupported = function() {
    var win = browserWindow();
    var doc = browserDocument();
    return !!(win && doc && win.JSON && doc.querySelectorAll && !!Array.prototype.forEach && !!doc.querySelector && location().href && win.btoa);
};
/**
 * Check to see if the current user agent looks like a spider/bot
 * @returns {boolean} true if bot, else false
 */
export var browserIsSpider = function() {
    /* tslint:disable */
    var re = /(bot|spider|scraper|crawl|agent|Mediapartners-Google|slurp|java|wget|curl|Commons-HttpClient|Python-urllib|libwww|httpunit|nutch|biglotron|teoma|convera|gigablast|ia_archiver|GingerCrawler|webmon |httrack|grub.org|netresearchserver|speedy|fluffy|bibnum.bnf|findlink|panscient|IOI|ips-agent|yanga|Voyager|CyberPatrol|postrank|page2rss|linkdex|ezooms|heritrix|findthatfile|europarchive.org|Aboundex|summify|ec2linkfinder|facebookexternalhit|yeti|RetrevoPageAnalyzer|sogou|wotbox|ichiro|drupact|coccoc|integromedb|siteexplorer.info|proximic|changedetection|WeSEE:Search|Lipperhey SEO Service|CC Metadata Scaper|g00g1e.net|binlar|A6-Indexer|ADmantX|MegaIndex|ltx71|BUbiNG|Qwantify|lipperhey|y!j-asr|AddThis|KTXN|Webmetrics|sessioncam|neustar|PingdomTMS|load|iplabel;|PhantomJS)/i; // tslint-disable-line
    /* tslint:enable */
    return re.test(userAgent());
};
/**
 * Starts a timeout and triggers the fn after finished.
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/setTimeout}
 * @param fn {function} the function that will be executed after timeout
 * @param timeout {integer} timeout in milliseconds after which fn will be invoked
 */
export var setTimeout = function(fn, timeout) {
    // tslint:disable-next-line:no-string-based-set-timeout
    return window.setTimeout(fn, timeout);
};
/**
 * Creates an element in the document and returns the Node (it doesnt append to DOM)
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Document/createElement}
 * @param doc {object} the document object it will be created
 * @param element {string} the element that you need to create eg: img, div, pre, p
 * @param opts {object} object with properties/attributes of the element
 */
export var createElement = function(doc, element, opts) {
    if (doc === void 0) {
        doc = browserDocument();
    }
    if (opts === void 0) {
        opts = {};
    }
    var elem = doc.createElement(element);
    if (typeof opts !== 'object') {
        return elem;
    }
    /* tslint:disable:no-for-in */
    for (var p in opts) {
        if ({}.hasOwnProperty.call(opts, p)) {
            elem.setAttribute(p, opts[p]);
        }
    }
    /* tslint:enable:no-for-in */
    return elem;
};
/**
 * Converts a NodeList to an array of nodes
 * @param nodes {NodeListOf<T>} the nodelist to convert
 * @returns {Array<T>} the array of nodes
 */
export var nodelistToArray = function(nodes) {
    var nodeArray = [];
    for (var i = 0; i < nodes.length; i += 1) {
        nodeArray.push(nodes[i]);
    }
    return nodeArray;
};
export {
    browserDocument as document, browserWindow as window
};
// some sites mess with prototypes on objects, causing standard json serialisation to fail
// this abstraction lets us override
var SafeJson = /** @class */ (function() {
    function SafeJson() {}
    SafeJson.stringify = function(value, replacer, space) {
        var win = browserWindow();
        if (win && win.sc_json) {
            return win.sc_json.stringify(value, replacer, space);
        }
        return JSON.stringify(value, replacer, space);
    };
    SafeJson.parse = function(text) {
        var win = browserWindow();
        if (win && win.sc_json) {
            return win.sc_json.parse(text);
        }
        return JSON.parse(text);
    };
    return SafeJson;
}());
export {
    SafeJson
};



//////////////////
// WEBPACK FOOTER
// ./node_modules/@salecycle/client-script-core/src/browser_abstraction.js
// module id = 0
// module chunks = 0